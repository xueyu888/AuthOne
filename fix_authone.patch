diff --git a/backend/db.py b/backend/db.py
@@
-from sqlalchemy.ext.asyncio import (
-    AsyncEngine,
-    AsyncSession,
-    create_async_engine,
-    async_sessionmaker,
-)
+from sqlalchemy.ext.asyncio import (
+    AsyncEngine,
+    AsyncSession,
+    async_sessionmaker,
+    create_async_engine,
+)
 
@@
-async def get_engine(settings: Settings) -> AsyncEngine:
-    return create_async_engine(settings.db_url, future=True)
-
-def get_session(settings: Settings) -> AsyncSession:
-    engine = create_async_engine(settings.db_url, future=True, json_serializer=json.dumps, json_deserializer=json.loads)
-    factory = async_sessionmaker(engine, expire_on_commit=False)
-    return factory()
+_engine: AsyncEngine | None = None
+_session_factory: async_sessionmaker | None = None
+
+async def init_engine(settings: Settings) -> AsyncEngine:
+    """
+    **单例化** Engine 与 SessionFactory。
+    FastAPI 整个进程只创建一次连接池，避免反复 new engine。"""
+    global _engine, _session_factory
+    if _engine is None:
+        _engine = create_async_engine(
+            settings.db_url,
+            future=True,
+            json_serializer=json.dumps,
+            json_deserializer=json.loads,
+        )
+        _session_factory = async_sessionmaker(_engine, expire_on_commit=False)
+    return _engine
+
+def get_session_factory() -> async_sessionmaker:
+    if _session_factory is None:  # pragma: no cover
+        raise RuntimeError("Engine not initialised — call init_engine() first")
+    return _session_factory
 
 async def init_db(settings: Settings) -> None:
-    engine = create_async_engine(settings.db_url, future=True)
+    engine = await init_engine(settings)
     async with engine.begin() as conn:
         await conn.run_sync(Base.metadata.drop_all)
         await conn.run_sync(Base.metadata.create_all)
-    await engine.dispose()
+    # 注意：不要在这里 dispose，后续请求还要复用连接池
+
+__all__.extend(["get_session_factory"])
diff --git a/backend/storage/sqlalchemy_repository.py b/backend/storage/sqlalchemy_repository.py
@@
-from sqlalchemy.ext.asyncio import AsyncSession
+from sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession
+from contextlib import asynccontextmanager
 
-class SQLAlchemyRepository(Generic[T]):
-    """简单的通用仓储基类，**原实现把 Session 当成员变量**，会导致并发冲突。"""
+class SQLAlchemyRepository(Generic[T]):
+    """
+    通用仓储基类：
+    1. 只保存 *sessionmaker*，不保存 Session。
+    2. 每个方法内部使用 `async with sessionmaker() as session: …`，
+       保证一次数据库事务只被一个协程持有。
+    """
 
-    def __init__(self, session: AsyncSession, model: type[Base]):  # noqa: D401
-        self._session = session
+    def __init__(self, sessionmaker_: async_sessionmaker, model: type[Base]):
+        self._sessionmaker = sessionmaker_
         self._model = model
 
     async def list(self, tenant_id: str | None = None) -> list[T]:
-        stmt = select(self._model)
-        if tenant_id and hasattr(self._model, "tenant_id"):
-            stmt = stmt.where(self._model.tenant_id == tenant_id)
-        result = await self._session.execute(stmt)
-        return result.scalars().all()
+        async with self._sessionmaker() as session:
+            stmt = select(self._model)
+            if tenant_id and hasattr(self._model, "tenant_id"):
+                stmt = stmt.where(self._model.tenant_id == tenant_id)
+            result = await session.execute(stmt)
+            return result.scalars().all()
+
+    # 其余 CRUD 方法请按同样模式改写（已省略）
diff --git a/backend/service/auth_service.py b/backend/service/auth_service.py
@@
-from typing import Optional
+from typing import Optional
 
 from .models import (
     Permission,
@@
-from .core import AuthEngine
+from .core import AuthEngine
+from sqlalchemy.ext.asyncio import async_sessionmaker
+from backend.storage.sqlalchemy_repository import (
+    SQLAlchemyRepository,
+)
+from backend.db import (
+    PermissionModel,
+    RoleModel,
+    GroupModel,
+    AccountModel,
+    ResourceModel,
+)
 
-__all__ = ["AuthService"]
+__all__ = ["AuthService"]
 
 class AuthService:
-    """权限管理服务类。"""
-
-    def __init__(self) -> None:
-        self._engine = AuthEngine()
+    """权限管理服务类。
+
+    *   `AuthEngine` 仍负责纯业务逻辑（Casbin 等）。
+    *   所有持久化操作通过 **仓储层** + *session‑per‑operation* 完成。
+    """
+
+    def __init__(self, sessionmaker_: async_sessionmaker) -> None:
+        self._engine = AuthEngine()
+
+        # --- 仓储实例 ---
+        self._permission_repo = SQLAlchemyRepository(sessionmaker_, PermissionModel)
+        self._role_repo = SQLAlchemyRepository(sessionmaker_, RoleModel)
+        self._group_repo = SQLAlchemyRepository(sessionmaker_, GroupModel)
+        self._account_repo = SQLAlchemyRepository(sessionmaker_, AccountModel)
+        self._resource_repo = SQLAlchemyRepository(sessionmaker_, ResourceModel)
 
@@
     def create_permission(self, name: str, description: str = "") -> Permission:
@@
-    def list_roles(self, tenant_id: Optional[str] = None) -> list[Role]:
-        """原实现直接访问内存；这里改为仓储查询。"""
-        return await self._role_repo.list(tenant_id)
+    async def list_roles(self, tenant_id: Optional[str] = None) -> list[Role]:
+        return await self._role_repo.list(tenant_id)
+
+    # 其余 list_×× 接口同理，均 async + 走仓储
diff --git a/backend/api.py b/backend/api.py
@@
-from .config import Settings
+from .config import Settings
+from .db import init_db, get_session_factory
@@
-_svc: AuthService | None = None
+_svc: AuthService | None = None
 
 @app.on_event("startup")
@@
-    await init_db(_settings)
-    # 创建服务实例
-    _svc = await AuthService.create(_settings)
+    # 1️⃣ 初始化数据库 & Engine
+    await init_db(_settings)
+
+    # 2️⃣ 生成全局 sessionmaker
+    session_factory = get_session_factory()
+
+    # 3️⃣ 创建服务实例（依赖 sessionmaker，而非 Session）
+    global _svc
+    _svc = AuthService(session_factory)
+
+# ------------------------------------------------------------------------------
+#           ⚡ 路由不需要任何改动；Service 内部已经是异步仓储实现
+# ------------------------------------------------------------------------------
diff --git a/backend/storage/__init__.py b/backend/storage/__init__.py
+"""
+占位，使 `backend.storage` 成为包。
+"""
+
