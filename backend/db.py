"""Database module for AuthOne.

This module defines SQLAlchemy ORM models and provides helper functions
for creating the asynchronous engine and session factory.  The ORM
models correspond directly to the domain concepts used by AuthOne
without any separate dataclass layer.  All tables are declared with
reasonable constraints (e.g. unique names) and use UUID primary keys.

The ``init_engine`` function must be called once at application
startup to configure the asynchronous database engine.  ``get_session``
returns a new ``AsyncSession`` bound to the engine; callers should
commit or rollback as appropriate.

``init_db`` creates all tables defined on the ``Base`` metadata.

``dispose_engine`` cleanly disposes the engine on shutdown.
"""

from __future__ import annotations

import json
import uuid
from typing import Any
from datetime import datetime

from sqlalchemy import (
    Table,
    Column,
    String,
    Text,
    Boolean,
    Integer,
    DateTime,
    ForeignKey,
)
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSON as PG_JSON
from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import declarative_base, relationship

__all__ = [
    "Base",
    "init_engine",
    "get_session",
    "dispose_engine",
    "init_db",
    "PermissionModel",
    "RoleModel",
    "GroupModel",
    "AccountModel",
    "ResourceModel",
    "AuditLogModel",
    "CasbinRuleModel",
    "role_permissions",
    "group_roles",
    "user_roles",
    "user_groups",
]

# ---------------------------------------------------------------------------
# SQLAlchemy base and association tables
#
# We use a declarative base for all ORM models.  Association tables are
# defined for the many-to-many relationships between roles and permissions,
# groups and roles, accounts and roles, and accounts and groups.

Base = declarative_base()

# Association table between roles and permissions
role_permissions = Table(
    "role_permissions",
    Base.metadata,
    Column(
        "role_id",
        PG_UUID(as_uuid=True),
        ForeignKey("roles.id", ondelete="CASCADE"),
        primary_key=True,
    ),
    Column(
        "permission_id",
        PG_UUID(as_uuid=True),
        ForeignKey("permissions.id", ondelete="CASCADE"),
        primary_key=True,
    ),
)

# Association table between groups and roles
group_roles = Table(
    "group_roles",
    Base.metadata,
    Column(
        "group_id",
        PG_UUID(as_uuid=True),
        ForeignKey("groups.id", ondelete="CASCADE"),
        primary_key=True,
    ),
    Column(
        "role_id",
        PG_UUID(as_uuid=True),
        ForeignKey("roles.id", ondelete="CASCADE"),
        primary_key=True,
    ),
)

# Association table between accounts and roles
user_roles = Table(
    "user_roles",
    Base.metadata,
    Column(
        "account_id",
        PG_UUID(as_uuid=True),
        ForeignKey("accounts.id", ondelete="CASCADE"),
        primary_key=True,
    ),
    Column(
        "role_id",
        PG_UUID(as_uuid=True),
        ForeignKey("roles.id", ondelete="CASCADE"),
        primary_key=True,
    ),
)

# Association table between accounts and groups
user_groups = Table(
    "user_groups",
    Base.metadata,
    Column(
        "account_id",
        PG_UUID(as_uuid=True),
        ForeignKey("accounts.id", ondelete="CASCADE"),
        primary_key=True,
    ),
    Column(
        "group_id",
        PG_UUID(as_uuid=True),
        ForeignKey("groups.id", ondelete="CASCADE"),
        primary_key=True,
    ),
)

# ---------------------------------------------------------------------------
# ORM models
#
# Each model uses a UUID primary key and defines relationships to other
# models via the association tables above.  We avoid adding any domain
# specific logic here; validation is performed at the Pydantic layer.  UUID
# primary keys are generated by the database (via default=uuid.uuid4) to
# ensure uniqueness.


class PermissionModel(Base):
    __tablename__ = "permissions"

    id: Any = Column(
        PG_UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    name: str = Column(String(255), unique=True, nullable=False)
    description: str | None = Column(Text, nullable=True)
    roles = relationship(
        "RoleModel",
        secondary=role_permissions,
        back_populates="permissions",
    )


class RoleModel(Base):
    __tablename__ = "roles"

    id: Any = Column(
        PG_UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    tenant_id: str | None = Column(String(255), nullable=True, index=True)
    name: str = Column(String(255), nullable=False)
    description: str | None = Column(Text, nullable=True)
    permissions = relationship(
        PermissionModel,
        secondary=role_permissions,
        back_populates="roles",
    )
    groups = relationship(
        "GroupModel",
        secondary=group_roles,
        back_populates="roles",
    )
    accounts = relationship(
        "AccountModel",
        secondary=user_roles,
        back_populates="roles",
    )


class GroupModel(Base):
    __tablename__ = "groups"

    id: Any = Column(
        PG_UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    tenant_id: str | None = Column(String(255), nullable=True, index=True)
    name: str = Column(String(255), nullable=False)
    description: str | None = Column(Text, nullable=True)
    roles = relationship(
        RoleModel,
        secondary=group_roles,
        back_populates="groups",
    )
    accounts = relationship(
        "AccountModel",
        secondary=user_groups,
        back_populates="groups",
    )


class AccountModel(Base):
    __tablename__ = "accounts"

    id: Any = Column(
        PG_UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    tenant_id: str | None = Column(String(255), nullable=True, index=True)
    username: str = Column(String(255), nullable=False)
    email: str = Column(String(255), unique=True, nullable=False)
    roles = relationship(
        RoleModel,
        secondary=user_roles,
        back_populates="accounts",
    )
    groups = relationship(
        GroupModel,
        secondary=user_groups,
        back_populates="accounts",
    )


class ResourceModel(Base):
    __tablename__ = "resources"

    id: Any = Column(
        PG_UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    type: str = Column(String(255), nullable=False)
    name: str = Column(String(255), nullable=False)
    tenant_id: str | None = Column(String(255), nullable=True, index=True)
    owner_id: Any = Column(
        PG_UUID(as_uuid=True),
        ForeignKey("accounts.id"),
        nullable=True,
    )
    resource_metadata: dict[str, Any] | None = Column(PG_JSON, nullable=True)


class AuditLogModel(Base):
    __tablename__ = "audit_logs"

    id: Any = Column(
        PG_UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    account_id: Any = Column(
        PG_UUID(as_uuid=True),
        ForeignKey("accounts.id"),
        nullable=False,
    )
    action: str = Column(String(255), nullable=False)
    resource: str | None = Column(String(255), nullable=True)
    result: bool = Column(Boolean, nullable=False)
    message: str | None = Column(Text, nullable=True)
    timestamp: datetime = Column(DateTime, default=datetime.utcnow, nullable=False)


class CasbinRuleModel(Base):
    """Model used by the Casbin built-in SQL adapter.

    If you use a database-backed adapter for Casbin policies (instead of a
    file), Casbin will store its policies in this table.  The columns v0-v5
    correspond to the parameters of a policy rule.
    """

    __tablename__ = "casbin_rules"

    id: int = Column(Integer, primary_key=True, autoincrement=True)
    ptype: str | None = Column(String(255))
    v0: str | None = Column(String(255))
    v1: str | None = Column(String(255))
    v2: str | None = Column(String(255))
    v3: str | None = Column(String(255))
    v4: str | None = Column(String(255))
    v5: str | None = Column(String(255))


# ---------------------------------------------------------------------------
# Engine and session management
_ENGINE: AsyncEngine | None = None
_SESSION_FACTORY: async_sessionmaker[AsyncSession] | None = None


def init_engine(db_url: str) -> None:
    """Initialise the asynchronous database engine.

    This function must be called exactly once at startup.  Subsequent calls
    are no-ops.  The engine is configured with JSON serialisation
    compatible with PostgreSQL's JSON type.

    :param db_url: SQLAlchemy database URL, e.g. ``postgresql+asyncpg://...``
    """
    global _ENGINE, _SESSION_FACTORY
    if _ENGINE is not None:
        return
    _ENGINE = create_async_engine(
        db_url,
        future=True,
        json_serializer=json.dumps,
        json_deserializer=json.loads,
    )
    _SESSION_FACTORY = async_sessionmaker(
        _ENGINE, expire_on_commit=False
    )


def get_session() -> AsyncSession:
    """Return a new asynchronous session bound to the global engine.

    Raises ``RuntimeError`` if the engine has not been initialised.  Each
    session is independent; the caller is responsible for committing or
    rolling back transactions and closing the session.
    """
    if _SESSION_FACTORY is None:
        raise RuntimeError("Engine not initialised; call init_engine() first")
    return _SESSION_FACTORY()


async def dispose_engine() -> None:
    """Dispose the global engine and clear session factory.

    After calling this function the engine is unusable.  Useful for
    graceful shutdown in FastAPI lifespan events.
    """
    global _ENGINE, _SESSION_FACTORY
    if _ENGINE is not None:
        await _ENGINE.dispose()
        _ENGINE = None
    _SESSION_FACTORY = None


async def init_db(drop_all: bool = False) -> None:
    """Create all tables defined on the ``Base`` metadata.

    If ``drop_all`` is true, all existing tables are dropped before
    creation.  This function requires that ``init_engine`` has been
    invoked.
    """
    if _ENGINE is None:
        raise RuntimeError("Engine not initialised; call init_engine() first")
    async with _ENGINE.begin() as conn:
        if drop_all:
            await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)